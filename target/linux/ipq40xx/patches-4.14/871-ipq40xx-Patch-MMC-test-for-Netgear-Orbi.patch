From c10486bb62077f63e5a46c74e6d840c593aa4a9b Mon Sep 17 00:00:00 2001
From: Robert Marko <robimarko@gmail.com>
Date: Wed, 29 Aug 2018 22:44:58 +0200
Subject: [PATCH] ipq40xx: Patch MMC test for Netgear Orbi

Signed-off-by: Robert Marko <robimarko@gmail.com>
---
 drivers/mmc/core/mmc_test.c | 161 ++++++++++++++++++++++++++++++++++++
 1 file changed, 161 insertions(+)

diff --git a/drivers/mmc/core/mmc_test.c b/drivers/mmc/core/mmc_test.c
index 789afef6..e0a3c096 100644
--- a/drivers/mmc/core/mmc_test.c
+++ b/drivers/mmc/core/mmc_test.c
@@ -44,6 +44,11 @@
  */
 #define TEST_AREA_MAX_SIZE (128 * 1024 * 1024)
 
+extern int redirect_console_oops_msg(char *buf, int len);
+static char dni_panic_buf[4096];
+static char dni_panic_flag[4096];
+static int devaddr_flag;
+int mmc_dni_erase(void);
 /**
  * struct mmc_test_pages - pages allocated by 'alloc_pages()'.
  * @page: first page in the allocation
@@ -1025,6 +1030,12 @@ static int mmc_test_transfer(struct mmc_test_card *test,
 /*  Tests                                                          */
 /*******************************************************************/
 
+#define ART_DEV_ADDR 0x2c22
+#define BOARD_DATA_BOOT_PARTITION_OFFSET 0x128 /* board_data offset: 0x124 + SKU length 4 */
+#define BOARD_DATA_BOOT_PARTITION_LENGTH 0x2 /* boot partition: 2 */
+#define DEFAULT_BOOT_PARTITON1 "01" /* the default boot partition "01" */
+#define DEFAULT_BOOT_PARTITON2 "02" /* the second boot partition "02" */
+
 struct mmc_test_case {
 	const char *name;
 
@@ -3091,6 +3102,156 @@ static int mtf_test_open(struct inode *inode, struct file *file)
 	return single_open(file, mtf_test_show, inode->i_private);
 }
 
+static struct mmc_card *dni_card;
+int mmc_dni_write(char panic_buf[4096])
+{
+	struct mmc_test_card *dni_test;
+
+	memcpy(dni_panic_buf,panic_buf,4096);
+	dni_test = kzalloc(sizeof(struct mmc_test_card), GFP_KERNEL);
+	if (!dni_test)
+	{
+		return -ENOMEM;
+	}
+	/*
+	 * Remove all test cases associated with given card. Thus we have only
+	 * actual data of the last run.
+	 */
+	mmc_test_free_result(dni_card);
+
+	dni_test->card = dni_card;
+
+	dni_test->buffer = kzalloc(BUFFER_SIZE, GFP_KERNEL);
+
+	if (dni_test->buffer) {
+		mutex_lock(&mmc_test_lock);
+		mmc_test_run(dni_test, 2);
+		mutex_unlock(&mmc_test_lock);
+	}
+
+	
+	kfree(dni_test->buffer);
+	kfree(dni_test);
+
+
+	return 0;
+}
+EXPORT_SYMBOL(mmc_dni_write);
+
+static struct mmc_card *dni_card;
+int mmc_dni_read(void)
+{
+	struct mmc_test_card *dni_test;
+
+	dni_test = kzalloc(sizeof(struct mmc_test_card), GFP_KERNEL);
+	if (!dni_test)
+	{
+		return -ENOMEM;
+	}
+	/*
+	 * Remove all test cases associated with given card. Thus we have only
+	 * actual data of the last run.
+	 */
+	mmc_test_free_result(dni_card);
+
+	dni_test->card = dni_card;
+
+	dni_test->buffer = kzalloc(BUFFER_SIZE, GFP_KERNEL);
+
+	if (dni_test->buffer) {
+		mutex_lock(&mmc_test_lock);
+		mmc_test_run(dni_test, 3);
+		mutex_unlock(&mmc_test_lock);
+	}
+
+	
+	kfree(dni_test->buffer);
+	kfree(dni_test);
+
+
+	return 0;
+}
+EXPORT_SYMBOL(mmc_dni_read);
+
+static struct mmc_card *dni_card;
+int mmc_dni_erase(void)
+{
+	struct mmc_test_card *dni_test;
+
+	dni_test = kzalloc(sizeof(struct mmc_test_card), GFP_KERNEL);
+	if (!dni_test)
+	{
+		return -ENOMEM;
+	}
+	/*
+	 * Remove all test cases associated with given card. Thus we have only
+	 * actual data of the last run.
+	 */
+	mmc_test_free_result(dni_card);
+
+	dni_test->card = dni_card;
+
+	dni_test->buffer = kzalloc(BUFFER_SIZE, GFP_KERNEL);
+
+	if (dni_test->buffer) {
+		mutex_lock(&mmc_test_lock);
+		mmc_test_run(dni_test, 1);
+		mutex_unlock(&mmc_test_lock);
+	}
+
+	
+	kfree(dni_test->buffer);
+	kfree(dni_test);
+
+
+	return 0;
+}
+EXPORT_SYMBOL(mmc_dni_erase);
+
+/*the boot partition number will be saved in part_no */
+static struct mmc_card *dni_card;
+int mmc_dni_art_read_boot_part(char *part_no)
+{
+	struct mmc_test_card *dni_test;
+
+	dni_test = kzalloc(sizeof(struct mmc_test_card), GFP_KERNEL);
+	if (!dni_test)
+	{
+		return -ENOMEM;
+	}
+	/*
+	 * Remove all test cases associated with given card. Thus we have only
+	 * actual data of the last run.
+	 */
+	mmc_test_free_result(dni_card);
+
+	dni_test->card = dni_card;
+
+	dni_test->buffer = kzalloc(BUFFER_SIZE, GFP_KERNEL);
+
+	if (dni_test->buffer) {
+		mutex_lock(&mmc_test_lock);
+		mmc_test_run(dni_test, 4);
+		mutex_unlock(&mmc_test_lock);
+	}
+
+	strncpy(part_no, dni_test->buffer + BOARD_DATA_BOOT_PARTITION_OFFSET, BOARD_DATA_BOOT_PARTITION_LENGTH);
+
+	if (strncmp(part_no, DEFAULT_BOOT_PARTITON1, BOARD_DATA_BOOT_PARTITION_LENGTH) && strncmp(part_no, DEFAULT_BOOT_PARTITON2, BOARD_DATA_BOOT_PARTITION_LENGTH)) {
+		/* if the part_no got from art is not equal to neither "01" nor "01", then reset boot paritition to part#1("01") */
+		strncpy(part_no, DEFAULT_BOOT_PARTITON1, BOARD_DATA_BOOT_PARTITION_LENGTH);
+		printk("mmc_art_verify_read failed. reset rootfs part to #%s\n", part_no);
+	}
+		printk("%s: rootfs part is #%s\n", __func__, part_no);
+	
+	kfree(dni_test->buffer);
+	kfree(dni_test);
+
+
+	return 0;
+}
+EXPORT_SYMBOL(mmc_dni_art_read_boot_part);
+
 static ssize_t mtf_test_write(struct file *file, const char __user *buf,
 	size_t count, loff_t *pos)
 {
-- 
2.17.1

