From 4707aab874bb31f99d7b2fe13a9feeca5f77dbdd Mon Sep 17 00:00:00 2001
From: Robert Marko <robimarko@gmail.com>
Date: Wed, 29 Aug 2018 19:39:22 +0200
Subject: [PATCH] Netgear Orbi: Use netgear EFI hack

Signed-off-by: Robert Marko <robimarko@gmail.com>
---
 block/partitions/efi.c | 115 +++++++++++++++++++++++++++++++++++++++++
 1 file changed, 115 insertions(+)

--- a/block/partitions/efi.c
+++ b/block/partitions/efi.c
@@ -103,12 +103,14 @@
 #include <linux/slab.h>
 #include "check.h"
 #include "efi.h"
+#include <linux/root_dev.h>
 
 /* This allows a kernel command line option 'gpt' to override
  * the test for invalid PMBR.  Not __initdata because reloading
  * the partition tables happens after init too.
  */
 static int force_gpt;
+static char saved_rootfs_name[64];
 static int __init
 force_gpt_fn(char *str)
 {
@@ -117,6 +119,13 @@ force_gpt_fn(char *str)
 }
 __setup("gpt", force_gpt_fn);
 
+static int __init rootfs_name_setup(char *line)
+{
+	strlcpy(saved_rootfs_name, line, sizeof(saved_rootfs_name));
+	return 1;
+}
+__setup("rootfsname=", rootfs_name_setup);
+
 
 /**
  * efi_crc32() - EFI version of crc32 function
@@ -689,6 +698,68 @@ static int find_valid_gpt(struct parsed_
  *  1 if successful
  *
  */
+
+struct dni_partition
+{
+	char name[32];
+	u32 start_r; /* Offset */
+	u32 size_r;  /* Size */
+};
+
+struct dni_partition dni_custom_part[] = {
+{"ARTMTD", 0x2A22, 0x200},
+{"language",0x2C22, 0x1000},
+{"config",  0x3C22, 0x200},
+{"pot",     0x3E22, 0x200},
+{"traffic_meter", 0x4022, 0x200},
+{"pot_bak", 0x4222, 0x200},
+{"traffic_meter.bak", 0x4422, 0x200},
+{"kernel",  0x4622, 0x1E00},
+{"rootfs",  0x6422, 0x17200},
+{"firmware",0x4622, 0x19000},
+{"mtdoops", 0x1D622, 0x200},						 
+{"kernel-2",  0x1D822, 0x1E00},
+{"rootfs-2",  0x1F622, 0x17200},
+{"firmware-2",0x1D822, 0x19000},
+{"cert", 0x36822, 0x200},
+{"device_table", 0x36A22, 0x2800},
+{"circle", 0x39222, 0x18000},
+{"streamboost", 0x51222, 0x19000},
+{"forceshield", 0x6A222, 0xF000},
+{"arlo", 0x79222, 0x2800},							 
+{"rae", 0x7BA22, 0x1000},
+{"reserved",0x7CA22, 0x24ECFF},
+
+};
+
+#define DEFAULT_BOOT_PARTITON2 "02" /* the default boot partition "01" */
+#define BOARD_DATA_BOOT_PARTITION_LENGTH 0x2 /* boot partition: 2 */
+
+/* read the rootfs partition number from ART.
+ * the parameter root= should be not set, otherwise this ROOT_DEV wil be covered.
+ */
+static void read_boot_part_from_art(struct parsed_partitions *state)
+{
+	char boot_part_num[3] = {0};
+	strncpy(boot_part_num, DEFAULT_BOOT_PARTITON2, BOARD_DATA_BOOT_PARTITION_LENGTH);
+	unsigned root_part;
+	/* read the boot partition number from mmc ART partition */
+	/* Hacked to not have to patch MMC_TEST, hardcoded to #01 */
+	pr_notice("%s: the rootfs part num is #%s\n", __func__, boot_part_num);
+
+	if (strncmp(boot_part_num, "02", 2) == 0)
+		root_part = 25; /* boot from the second rootfs */
+	else
+		root_part = 20;
+
+	if (ROOT_DEV == 0 && IS_REACHABLE(CONFIG_MTD_ROOTFS_ROOT_DEV)) {
+		ROOT_DEV = MKDEV(MAJOR(state->bdev->bd_dev), root_part);
+		pr_notice("ART part: device [%d:%d] mmcblk0p%d set to be root filesystem\n",
+				MAJOR(ROOT_DEV), MINOR(ROOT_DEV),
+				root_part);
+	}
+}
+
 int efi_partition(struct parsed_partitions *state)
 {
 	gpt_header *gpt = NULL;
@@ -696,6 +767,9 @@ int efi_partition(struct parsed_partitio
 	u32 i;
 	unsigned ssz = bdev_logical_block_size(state->bdev) / 512;
 
+	if (!saved_rootfs_name[0])
+		strlcpy(saved_rootfs_name, "rootfs", sizeof("rootfs"));
+
 	if (!find_valid_gpt(state, &gpt, &ptes) || !gpt || !ptes) {
 		kfree(gpt);
 		kfree(ptes);
@@ -704,6 +778,8 @@ int efi_partition(struct parsed_partitio
 
 	pr_debug("GUID Partition Table is valid!  Yea!\n");
 
+	read_boot_part_from_art(state);
+
 	for (i = 0; i < le32_to_cpu(gpt->num_partition_entries) && i < state->limit-1; i++) {
 		struct partition_meta_info *info;
 		unsigned label_count = 0;
@@ -735,8 +811,47 @@ int efi_partition(struct parsed_partitio
 			info->volname[label_count] = c;
 			label_count++;
 		}
+
+		pr_notice("#: vol name is %s, start is 0x%llx, size is 0x%llx, ssz is 0x%x\n", info->volname, start, size, ssz);
+		if (ROOT_DEV == 0 &&
+		    !strcmp(info->volname, saved_rootfs_name) &&
+		    IS_REACHABLE(CONFIG_MTD_ROOTFS_ROOT_DEV)) {
+			ROOT_DEV = MKDEV(MAJOR(state->bdev->bd_dev), i + 1);
+			pr_notice("GPT: device [%d:%d] (%s) set to be root filesystem\n",
+				MAJOR(ROOT_DEV), MINOR(ROOT_DEV),
+				info->volname);
+		}
 		state->parts[i + 1].has_info = true;
 	}
+
+	/* Append Define the partition by DNI */
+	int j, k;
+	j = 0;
+	k = 0;
+	k = ((i >= 5) ? (i - 5) : 0); /* decide the partition number */
+	for (j = 0; j < (sizeof(dni_custom_part) / sizeof(struct dni_partition)); j++){
+		struct partition_meta_info info_r;
+		u64 start_r, size_r;
+
+		start_r = dni_custom_part[j].start_r;
+		size_r = dni_custom_part[j].size_r;
+
+		put_partition(state, k+1, start_r * ssz, size_r * ssz);
+		strcpy(info_r.volname, dni_custom_part[j].name);
+
+		pr_notice("#: vol name is %s, start is 0x%llx, size is 0x%llx, ssz is 0x%x\n", info_r.volname, start_r, size_r, ssz);
+		if (ROOT_DEV == 0 && !strcmp(info_r.volname, "rootfs") &&
+			IS_REACHABLE(CONFIG_MTD_ROOTFS_ROOT_DEV)) {
+				ROOT_DEV = MKDEV(MAJOR(state->bdev->bd_dev), k + 1);
+				pr_notice("GPT: device [%d:%d] (%s) set to be root filesystem\n",
+					MAJOR(ROOT_DEV), MINOR(ROOT_DEV),
+					info_r.volname);
+		}
+		state->parts[k + 1].has_info = true;
+
+		k++;
+	}
+
 	kfree(ptes);
 	kfree(gpt);
 	strlcat(state->pp_buf, "\n", PAGE_SIZE);
